# Schema Definitions & Migrations

- How are meta schemas created? What is their purpose and what are limitations?

- How do we define what log ids I'm writing to? Is it one log id per schema? Or many?

This section describes the data format for *schema messages*. Schema messages contain instructions for forming both a database schema and message format.

As an example, the *slothmail* schema is described in a sequence of *schema messages*, which are published by the slothmail authors on the slothmail log. (A slothmail client is then implementing this schema and allows end users to create *instance messages*, which contain the slothmail *instances* they send each other. A server reads users' slothmail *instance messages* and creates a materialized view of slothmail *instances*.)


## Creating a new schema

The `panda` command line application is used to register a new schema for the fictional *slothmail* application.

```bash
$ panda schema slothmail init --description "Send slothmail to your friends!"
üêº Registered slothmail schema at log 12
```

The *slothmail* schema's bamboo log was initialized in the local user's log number 12.

A couple of fields are added to the schema by reading from a migration definition:

```bash
$ panda schema slothmail migrate slothmail-001.yaml
Created fields
- subject<text>
- body<text>
- created<datetime>
- recipient<panda-profile>

üêº Published slothmail version 2
```

The *slothmail* application can now start publishing slothmail messages.

#### More possibilities
(comments from adz)

Every user can use the `panda` command line too to create new schema messages. For example the user with the public address `d4a1cb88...` creates a new schema of type `comment`:

```
$ panda schema init --file comment-001.toml
üêº Registered comment schema
```

The `comment-001.toml` file could look like this:

```toml
[meta]
name = "comment"
description = "Send comments to your friends!"
spec = 1

[fields.body]
type = "text"

[fields.created]
type = "timestamp"
```

... another way could be to use an client / web application which offers a nice wizard-like UI to manage a schema step by step.

The created message / bamboo entry payload could look like this. The message format is following the same specification as all other messages (including a `kind`, `schema` and `spec` field in the root):

```yml
kind: create
schema: schema
spec: 1 # this is the message spec version
fields:
  name: comment
  description: Send comments to your friends!
  spec: 1 # this is the schema spec version
  fields:
    - subject:
      type: text
    - body:
      type: text
    - created:
      type: timestamp
```

The client can send this message to the server where it will be stored in system log `0` of this user.

##### Register schema

To use this newly introduced schema the administrator can register it via command line:

```
panda schema register --name comment --address d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb
üéç Now indexing comment messages
```

It would throw an error if it couldn't find any schemas of type `comment` from this address.

The server would check if an schema of type `comment` was already registered. In this case it would create a temporary new table and run the indexing mechanism, scanning all logs again to find messages of type `comment`.

Please note here that the server will ignore all messages of type `comment` which do not follow the schema. This puts an extra responsibility on the creator of the schema and the administrator to not mess too much with breaking conventions. In case something important has to be changed a) clients have to be updated to support that change or b) a new name has to be introduced.

Schemes which refer to other schemes (relations), can be registered but are only indexed when all schemes are registered. The server would register the schema and put them in some sort of waiting queue for indexing until all requirements are fulfilled.

##### Namespace / Version conflicts

We can imagine another user creating a scheme with the same name `comment`. The server admin addresses which schema is meant by refering to the creators public address. For the client this distinction is not being made which puts a responsibility and community effort to maintain a common understanding on what names are used (similar to SSB and ActivityPub).

This is a tradeoff to allow for simpler GraphQL queries automatically generated by services like Postgraphile, otherwise we would need to add to every query which schema we refer to and propably build our own GraphQL resolver.

```
comments {
  body
  created
}

vs.

comments(schemaAddress: "d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb", schemaVersion: 2) {
  body
  created
}
```

## Materializing a new schema on a server

All p2panda servers make available their user's log entries to each other. In addition to that, they can offer materialized views of some of the data contained in those logs. For this, server administrators instruct the server to index messages of a certain schema.

Here, the *slothmail* schema is indexed. It is referred to by the public key of the schema's author and the log id in which that author published the schema.

```bash
$ beep-beep-server index 88e1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb 12
üéç Now indexing slothmail messages
```

## Initial Schema instantiation

When indexing a schema, a server executes all migrations in the schema‚Äôs log in order to create a database table capable of holding instances of the schema at its latest known version. Now, all known *instance messages* can be inserted into the database, which results in the database contents representing a view of all known instances at their latest versions.

Migrations can also be applied to messages in order to make them compatible with the current schema version. When an incoming message specifies a schema version older than the latest known schema version, all intermittent migrations are applied to this message so that it can be applied to the database. When a message specifies a schema version that is not known, the server tries to request that schema version‚Äôs entry using bamboo.

## Schema migration messages

A schema describes a database schema and a message specification through a series of schema migrations. A schema is represented by a bamboo log. Every message on the log is a schema migration. Thereby, the version number of a schema migration is the *sequence number* of the migration's log entry.

Each schema migration is one of:

- `schema-meta`: sets schema metadata
- `schema-migration`: Used by server to create or alter database tables and to migrate *instance messages*.
- `schema-revert`: Used by server to revert to an earlier version, recreating instance data, which may have been deleted or corrupted by intermittent migrations.

Schema migrations are encoded using a subset of [CDDL](https://tools.ietf.org/html/rfc8610#page-5). Examples in this draft are encoded in YAML.

### Meta schema message

A meta schema message describes the schema itself. It contains following fields. Only those marked with an X in the "Required" column are required.

| Field name | Description | Required |
| --- | --- | --- |
| name | Name of the schema | X |
| spec | Which verison of this schema meta-spec is implemented | X |
| description | Description of the schema's purpose | |
| homepage | URL pointing at a web site for the schema | |
| license | A comma-separated list of licenses that apply for the schema definition | |
| contact | An email-address for contacting the schema's authors | |

#### Examples

Minimal meta schema message for a fictional messaging format *slothmail*.

```yaml
kind: schema-meta
name: slothmail
spec: 1
```

Example using all available fields

```yaml
kind: schema-meta
name: slothmail
spec: 1
description: Send slothmail to your friends!
homepage: https://liebechaos.org/activity/slothmail
license: CC-BY-SA 2.0 <https://creativecommons.org/licenses/by-sa/2.0/>
contact: info@liebechaos.org
```

### Migrate schema message

A migrate schema message creates or alters the schema‚Äôs table and updates its rows. A migration describes changes to one or more fields. If no database table exists for the schema, a new database table is created when applying the message. Server implementations should consider that schema names are non-unique when constructing table names.

Fields may be created, updated or removed. For each created or updated field, a new data type is specified. For updated fields, a default value must be specified that is stored if conversion to the new data type fails. Each field is described by its

- action (`create`, `update`, or `remove`)
- name (unicode string)
- type (see below)
- validation (optional regex pattern)

Type must be one of:

- `varchar` (max 255 chars)
- `text`
- `integer`
- `float`
- `boolean`
- `timestamp` (ISO-8601 timestamp)
- `relation`

Every type may also be specified as an array by adding `[]` behind the type name.

A `relation` type also specifies the `versioned-schema` of its foreign key. A `relation` type may specify `cascade: true` in which case schema instances are deleted once the foreign key is deleted.

The field `validation` may contain a regular expression used to validate messages of this schema.

If a `schema-migration` message removes the last of a schema‚Äôs fields, the schema‚Äôs database table may be dropped.

#### Examples

Example to create the *slothmail* schema

```yaml
kind: schema-migration
fields:
  - subject:
    action: create
    type: text
  - body:
    action: create
    type: text
  - recipient:
    action: create
    type: relation
    schema:
      # author for the schema of the recipient field
      - d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb
      # schema's log id
      - 10
      # relation is schema-version agnostic
  - created:
    action: create
    type: timestamp
```

Example to add an attachments field to the slothmail schema:

```yaml
kind: schema-migration
fields:
  - attachments:
    action: create
    type: relation[]
    schema:
      - ac1b08420ceaac230839b755845a9ffbd4a1cb88a66f02f8db635ce26441cc5d
      - 78434
```

Example to remove the attachments field and change the subject to not contain line breaks

```yaml
kind: schema-migration
fields:
  - attachments
    action: remove
  - subject
    action: update
    validation: ^[^#\r\n].*$
    default: <Subject>
```
### Revert schema message

A revert schema message reverts previous migrations and resets the database to a previous schema version (`target`). This is desirable instead of reverting by altering fields in order to restore data deleted by previous migrations.

The database is recreated by dropping the database and reapplying all known instance messages and all migrations up to the target migration. `create` and `update` instance messages, which specify a schema version later than the target version are ignored. `delete` instance messages are applied regardless of the version mismatch in order to prevent schema authors from restoring user data against their will.

#### Examples

The previous example removed the `attachments` field. During migration all slothmail attachments were deleted from slothmail instances. Simply adding the field back would not recover the deleted attachments. Here, the schema is reverted to a previous version that still had the `attachments` field, which recreates all the attachments by re-indexing all slothmail instances.

```yaml
kind: schema-revert
target: 2
```

### Some thoughts on migrations
(comments from adz)

Even though I like the idea of introducing migrations inside of bamboo entries I'm still not 100% convinced this is the right way. I'll try to list up some pro/cons to understand better where my thoughts are:

* Pro: Nice way to get schemas from the "network". A little bit like a built-in "app store" on beep-beep where you can fetch your schemas from other users.
* Pro: Gives a nice opportunity to build a schema explorer client
* Con: The usability from an administrator / server-owner perspective feels complicated and this might lead to errors / mistakes. The question is: How would the flow look like in an everyday-beep-beep-use?
    1. I install beep-beep on my linux server
    2. I whitelist my public address in an command line interface on the server to make it accept incoming migrations from this address
    3. I install another tool which sends migration messages to my server
    4. I read up somewhere what migration messages are interesting for me / write my own
    5. I put them into the command line tool and hope that I executed everything in the right order and did not do any mistakes as a beginner

    ... another scenario would be to find someones public address of which I know of who posted the migrations I'm interested in but then I ..
    1. have to find that address, put it into the whitelist via command line interface
    2. make sure its still somewhere on the network and I got the data before I can start at all to use my server ..

I think there is ways to improve that UX a lot but still I wonder if it isn't easier to have a file in the folder which describes the [schema once](https://en.wikipedia.org/wiki/Schema_migration). With every change of that file the database gets wiped and rebuilt. When something went wrong I track down the problem in my file and start again. As a server admin I see directly what my server is capable of by just reading the file. Another scenario could be to have multiple schema files just in case you want to organize them that way or install "plugins" (eg. copy just another schema file in that folder and restart the server). Aaaaanother cool thing: Schema folders can be organized as git repositories.

A thing between these two solutions could be to not have single atomic migrations described by every message but actually the "final" schema per message. Thats maybe not as flexible but at least easier to grasp and somehow I can imagine "default schemas" and combinations of them will establish much more likely?

Many thoughts!

### Multiple logs per user
(comments from adz)

#### Introduction

Every user can maintain multiple bamboo logs. Every log has its own unique `log_id` (see https://github.com/AljoschaMeyer/bamboo#concepts-and-properties). Logs hold entries with different messages inside, but have one limitation: Each log can only hold messages of the same type for. An log with multiple / mixed types is considered invalid and will be rejected by the server.

#### Log types

The type of a log is defined by its first message. These logs are named `user logs` except of so called `system logs` which have pre-defined message types.

To separate the log types we define a numbering schema for the `log_id`:

* Logs with ids `0-1023` are `system logs`
* Logs with ids `1024-‚àû` are `user logs`

##### Type: System log

So far only system log `0` is defined in this specification but the other 1023 "free" system logs are kept for future protocol changes or new extensions (for example blob handling, name resolving, encryption etc.).

* System log `0` accepts messages of type `schema`

##### Type: User logs

No user log exists yet on the server when a client generates a new keypair. In the moment the clients sends its (first) message to the server, let's say an create instance message of type `comment` ...

```yml
kind: create
schema: comment
spec: 1
fields:
  - body: Your concert was nice!
  - created: 2020-05-31T22:51:04+0000
```

... the following happens:

1. Client asks server about the next `backlink` and `limpaa link` for the next message of type `comment`. This is a required step to sign new bamboo entries on the clients side. The server looks into the database and checks if already any user log for `comment` exists. Since this is the very first message of this user, it can't find anything.

    ```
    nextEntryArguments {
      schemaName: "comment",
    }
    ```

    The server would reject this request if messages of type `comment` are not accepted. For now we assume they are accepted.

2. The server picks the next unused user log id, which in this case is `1024` (it is the first possible user log id) and sends it back to the client including `null` for the `backlink` and `limpaa link` field as no entries exist yet.

    ```
    {
      log_id: 1024,
      backlink_hash: null,
      lipmaalink_hash: null,
    }
    ```

3. With this data the client can encode the new bamboo entry now and send it finally to the server.

    ```
    postEntry {
      entryBytes: [...],
      payloadBytes: [...],
    }
    ```

    This encoded entry contains all required information for the server, including the `log_id`.

4. After validating the bamboo entry integrity the server checks (again) if it accepts messages of type `comment`. It also checks if the message is well-formed and all fields are following the defined schema. (Schemas are stored in system log `0` but live in memory of the server to improve the speed of validation and be able to pre-compile regex checks.)

5. Since we know the `log_id` from the entry the server checks if there are already any existing entries and which type they have. If it is not `comment` the request will be rejected. In this example the log is empty so the entry will just be inserted into the database.

Now the user maintains a user log of type `comment` at log id `1024`. All future `comment` messages will be placed in this log!
